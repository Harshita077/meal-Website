'use strict';

class CancelError extends Error {
	constructor(reason) {
		super(reason || 'Promise was canceled');
		this.name = 'CancelError';
	}

	get isCanceled() {
		return true;
	}
}

class PCancelable {
	static fn(userFn) {
<<<<<<< HEAD
		return (...arguments_) => {
			return new PCancelable((resolve, reject, onCancel) => {
				arguments_.push(onCancel);
				// eslint-disable-next-line promise/prefer-await-to-then
				userFn(...arguments_).then(resolve, reject);
=======
		return (...args) => {
			return new PCancelable((resolve, reject, onCancel) => {
				args.push(onCancel);
				userFn(...args).then(resolve, reject);
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
			});
		};
	}

	constructor(executor) {
		this._cancelHandlers = [];
		this._isPending = true;
		this._isCanceled = false;
		this._rejectOnCancel = true;

		this._promise = new Promise((resolve, reject) => {
			this._reject = reject;

			const onResolve = value => {
<<<<<<< HEAD
				if (!this._isCanceled || !onCancel.shouldReject) {
					this._isPending = false;
					resolve(value);
				}
=======
				this._isPending = false;
				resolve(value);
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
			};

			const onReject = error => {
				this._isPending = false;
				reject(error);
			};

			const onCancel = handler => {
<<<<<<< HEAD
				if (!this._isPending) {
					throw new Error('The `onCancel` handler was attached after the promise settled.');
				}

=======
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
				this._cancelHandlers.push(handler);
			};

			Object.defineProperties(onCancel, {
				shouldReject: {
					get: () => this._rejectOnCancel,
<<<<<<< HEAD
					set: boolean => {
						this._rejectOnCancel = boolean;
=======
					set: bool => {
						this._rejectOnCancel = bool;
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
					}
				}
			});

			return executor(onResolve, onReject, onCancel);
		});
	}

	then(onFulfilled, onRejected) {
<<<<<<< HEAD
		// eslint-disable-next-line promise/prefer-await-to-then
=======
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
		return this._promise.then(onFulfilled, onRejected);
	}

	catch(onRejected) {
		return this._promise.catch(onRejected);
	}

	finally(onFinally) {
		return this._promise.finally(onFinally);
	}

	cancel(reason) {
		if (!this._isPending || this._isCanceled) {
			return;
		}

<<<<<<< HEAD
		this._isCanceled = true;

=======
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
		if (this._cancelHandlers.length > 0) {
			try {
				for (const handler of this._cancelHandlers) {
					handler();
				}
			} catch (error) {
				this._reject(error);
<<<<<<< HEAD
				return;
			}
		}

=======
			}
		}

		this._isCanceled = true;
>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
		if (this._rejectOnCancel) {
			this._reject(new CancelError(reason));
		}
	}

	get isCanceled() {
		return this._isCanceled;
	}
}

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

module.exports = PCancelable;
<<<<<<< HEAD
=======
module.exports.default = PCancelable;

>>>>>>> 40382d3b0b471bff4769d59b78ba05eaee0535c2
module.exports.CancelError = CancelError;
